# 09: BPMIOCè®¾è®¡æ¨¡å¼åº”ç”¨

> **éš¾åº¦**: â­â­â­â­â˜†
> **é¢„è®¡æ—¶é—´**: 70åˆ†é’Ÿ
> **å‰ç½®çŸ¥è¯†**: 01-architecture-overview.md

## ğŸ“‹ æœ¬æ–‡ç›®æ ‡

æœ¬æ–‡åˆ†æBPMIOCä¸­åº”ç”¨çš„è½¯ä»¶è®¾è®¡æ¨¡å¼ï¼Œå¸®åŠ©ä½ ç†è§£æ¶æ„è®¾è®¡çš„æ·±å±‚ç†å¿µã€‚

å®Œæˆæœ¬æ–‡åï¼Œä½ å°†èƒ½å¤Ÿï¼š
- âœ… è¯†åˆ«BPMIOCä½¿ç”¨çš„è®¾è®¡æ¨¡å¼
- âœ… ç†è§£æ¯ä¸ªæ¨¡å¼çš„ä½œç”¨
- âœ… èƒ½å¤Ÿåœ¨è‡ªå·±çš„é¡¹ç›®ä¸­åº”ç”¨è¿™äº›æ¨¡å¼
- âœ… è¯„ä¼°æ¶æ„è®¾è®¡çš„ä¼˜åŠ£

## ğŸ¨ è®¾è®¡æ¨¡å¼æ€»è§ˆ

BPMIOCä½¿ç”¨äº†ä»¥ä¸‹ç»å…¸è®¾è®¡æ¨¡å¼ï¼š

| è®¾è®¡æ¨¡å¼ | åº”ç”¨ä½ç½® | ä½œç”¨ |
|---------|---------|------|
| **åˆ†å±‚æ¶æ„ï¼ˆLayered Architectureï¼‰** | æ•´ä½“æ¶æ„ | åˆ†ç¦»å…³æ³¨ç‚¹ |
| **ç­–ç•¥æ¨¡å¼ï¼ˆStrategy Patternï¼‰** | Offsetç³»ç»Ÿ | åŠ¨æ€é€‰æ‹©è¯»å–ç­–ç•¥ |
| **å·¥å‚æ¨¡å¼ï¼ˆFactory Patternï¼‰** | EPICS dset | åˆ›å»ºè®¾å¤‡æ”¯æŒå¯¹è±¡ |
| **å•ä¾‹æ¨¡å¼ï¼ˆSingleton Patternï¼‰** | å…¨å±€ç¼“å†²åŒº | å”¯ä¸€æ•°æ®æº |
| **è§‚å¯Ÿè€…æ¨¡å¼ï¼ˆObserver Patternï¼‰** | I/Oä¸­æ–­æ‰«æ | äº‹ä»¶é€šçŸ¥ |
| **é€‚é…å™¨æ¨¡å¼ï¼ˆAdapter Patternï¼‰** | ç¡¬ä»¶åº“å°è£… | ç»Ÿä¸€æ¥å£ |
| **å¤–è§‚æ¨¡å¼ï¼ˆFacade Patternï¼‰** | driverWrapper | ç®€åŒ–æ¥å£ |

## 1ï¸âƒ£ åˆ†å±‚æ¶æ„ï¼ˆLayered Architectureï¼‰

### æ¨¡å¼å®šä¹‰

å°†ç³»ç»Ÿç»„ç»‡æˆå±‚æ¬¡ç»“æ„ï¼Œæ¯å±‚åªä¸ç›¸é‚»å±‚äº¤äº’ã€‚

### BPMIOCåº”ç”¨

```
+-------------------+
|   æ•°æ®åº“å±‚ï¼ˆDBï¼‰   |  â† .dbæ–‡ä»¶ï¼ŒRecordå®šä¹‰
+-------------------+
         â†• dsetæ¥å£
+-------------------+
|  è®¾å¤‡æ”¯æŒå±‚ï¼ˆDevï¼‰  |  â† devBPMMonitor.c
+-------------------+
         â†• å‡½æ•°è°ƒç”¨
+-------------------+
|   é©±åŠ¨å±‚ï¼ˆDriverï¼‰ |  â† driverWrapper.c
+-------------------+
         â†• dlopen/dlsym
+-------------------+
|  ç¡¬ä»¶åº“ï¼ˆHardwareï¼‰|  â† libBPMboard14And15.so
+-------------------+
```

### ä¼˜ç‚¹

âœ… **å…³æ³¨ç‚¹åˆ†ç¦»**ï¼šæ¯å±‚èŒè´£æ˜ç¡®
âœ… **å¯æ›¿æ¢æ€§**ï¼šå¯ä»¥æ›¿æ¢ä»»ä½•ä¸€å±‚è€Œä¸å½±å“å…¶ä»–å±‚
âœ… **å¯æµ‹è¯•æ€§**ï¼šå¯ä»¥ç‹¬ç«‹æµ‹è¯•æ¯ä¸€å±‚
âœ… **å¯ç»´æŠ¤æ€§**ï¼šä¿®æ”¹åªå½±å“ä¸€å±‚

### ä»£ç ç¤ºä¾‹

```c
// æ•°æ®åº“å±‚ï¼ˆé«˜å±‚ï¼‰
record(ai, "LLRF:BPM:RF3Amp") {
    field(DTYP, "BPM")    // æŒ‡å®šè®¾å¤‡æ”¯æŒå±‚
    field(INP, "@0:3")    // å‚æ•°ä¼ é€’ç»™è®¾å¤‡æ”¯æŒå±‚
}

// è®¾å¤‡æ”¯æŒå±‚ï¼ˆä¸­å±‚ï¼‰
long read_ai(aiRecord *prec) {
    // è°ƒç”¨é©±åŠ¨å±‚
    value = ReadData(offset, channel, type);
    prec->val = value;
}

// é©±åŠ¨å±‚ï¼ˆä½å±‚ï¼‰
float ReadData(int offset, ...) {
    // è°ƒç”¨ç¡¬ä»¶åº“
    return GetRFInfo(channel, type);
}
```

## 2ï¸âƒ£ ç­–ç•¥æ¨¡å¼ï¼ˆStrategy Patternï¼‰

### æ¨¡å¼å®šä¹‰

å®šä¹‰ä¸€ç³»åˆ—ç®—æ³•ï¼Œå°†æ¯ä¸ªç®—æ³•å°è£…èµ·æ¥ï¼Œä½¿å®ƒä»¬å¯ä»¥äº’æ¢ã€‚

### BPMIOCåº”ç”¨ï¼šOffsetç³»ç»Ÿ

```c
// ç­–ç•¥æ¥å£ï¼šReadData()
float ReadData(int offset, int channel, int type)
{
    // æ ¹æ®offseté€‰æ‹©ä¸åŒçš„ç­–ç•¥
    switch (offset)
    {
        case 0:  // ç­–ç•¥1ï¼šè¯»å–RFä¿¡æ¯
            return strategy_read_rf(channel, type);

        case 7:  // ç­–ç•¥2ï¼šè¯»å–XYä½ç½®
            return strategy_read_xy(channel);

        case 10: // ç­–ç•¥3ï¼šè®¡ç®—å·®åˆ†å€¼
            return strategy_calc_diff(channel);

        // ... æ›´å¤šç­–ç•¥
    }
}

// å…·ä½“ç­–ç•¥å®ç°
float strategy_read_rf(int channel, int type) {
    return GetRFInfo(channel, type);
}

float strategy_read_xy(int channel) {
    return GetXYPosition(channel);
}

float strategy_calc_diff(int channel) {
    return GetVabcdValue(0) - GetVabcdValue(2);
}
```

### ä¼˜ç‚¹

âœ… **å¼€æ”¾å°é—­åŸåˆ™**ï¼šæ·»åŠ æ–°offsetç±»å‹ä¸å½±å“ç°æœ‰ä»£ç 
âœ… **æ¶ˆé™¤if-else**ï¼šä½¿ç”¨switchå®ç°ç­–ç•¥é€‰æ‹©
âœ… **æ˜“äºæ‰©å±•**ï¼šæ·»åŠ æ–°ç­–ç•¥åªéœ€æ·»åŠ æ–°case

### UMLå›¾

```
<<interface>>
ReadData(offset, channel, type)
         â†‘
         |
   â”Œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
   |     |     |     |     |
 case0 case7 case10 ...  caseN
 (RF)  (XY)  (Diff)      (æ–°ç­–ç•¥)
```

## 3ï¸âƒ£ å·¥å‚æ¨¡å¼ï¼ˆFactory Patternï¼‰

### æ¨¡å¼å®šä¹‰

å®šä¹‰ä¸€ä¸ªåˆ›å»ºå¯¹è±¡çš„æ¥å£ï¼Œè®©å­ç±»å†³å®šå®ä¾‹åŒ–å“ªä¸ªç±»ã€‚

### BPMIOCåº”ç”¨ï¼šEPICSè®¾å¤‡æ”¯æŒè¡¨ï¼ˆdsetï¼‰

```c
// è®¾å¤‡æ”¯æŒè¡¨ = å·¥å‚

// AIå·¥å‚
struct {
    long      number;
    DEVSUPFUN report;
    DEVSUPFUN init;
    DEVSUPFUN init_record;   // â† åˆ›å»ºæ–¹æ³•
    DEVSUPFUN get_ioint_info;
    DEVSUPFUN read;          // â† è¯»å–æ–¹æ³•
} devAi = {
    6,
    NULL,
    NULL,
    init_record_ai,  // åˆ›å»ºAI Recordæ”¯æŒå¯¹è±¡
    NULL,
    read_ai,         // è¯»å–AI Record
};

// AOå·¥å‚
struct {
    // ...
} devAo = {
    6,
    NULL,
    NULL,
    init_record_ao,  // åˆ›å»ºAO Recordæ”¯æŒå¯¹è±¡
    NULL,
    write_ao,        // å†™å…¥AO Record
};

// Waveformå·¥å‚
struct {
    // ...
} devWf = {
    6,
    NULL,
    NULL,
    init_record_wf,  // åˆ›å»ºWaveformæ”¯æŒå¯¹è±¡
    NULL,
    read_wf,         // è¯»å–Waveform
};
```

### ä½¿ç”¨å·¥å‚

```
# æ•°æ®åº“å±‚é€‰æ‹©å·¥å‚
record(ai, "LLRF:BPM:RF3Amp") {
    field(DTYP, "BPM")  # â† é€‰æ‹©"BPM"å·¥å‚ï¼ˆdevAiï¼‰
}

record(ao, "LLRF:BPM:SetOffset") {
    field(DTYP, "BPM")  # â† é€‰æ‹©"BPM"å·¥å‚ï¼ˆdevAoï¼‰
}
```

### ä¼˜ç‚¹

âœ… **è§£è€¦åˆ›å»ºå’Œä½¿ç”¨**ï¼šæ•°æ®åº“å±‚ä¸éœ€è¦çŸ¥é“å¦‚ä½•åˆ›å»ºè®¾å¤‡æ”¯æŒå¯¹è±¡
âœ… **ç»Ÿä¸€æ¥å£**ï¼šæ‰€æœ‰Recordç±»å‹ä½¿ç”¨ç›¸åŒçš„dsetæ¥å£
âœ… **æ˜“äºæ‰©å±•**ï¼šæ·»åŠ æ–°Recordç±»å‹åªéœ€å®šä¹‰æ–°å·¥å‚

## 4ï¸âƒ£ å•ä¾‹æ¨¡å¼ï¼ˆSingleton Patternï¼‰

### æ¨¡å¼å®šä¹‰

ç¡®ä¿ä¸€ä¸ªç±»åªæœ‰ä¸€ä¸ªå®ä¾‹ï¼Œå¹¶æä¾›å…¨å±€è®¿é—®ç‚¹ã€‚

### BPMIOCåº”ç”¨ï¼šå…¨å±€ç¼“å†²åŒº

```c
// driverWrapper.c

// å•ä¾‹ï¼šå…¨å±€å”¯ä¸€çš„æ•°æ®ç¼“å†²åŒº
static float rf3amp[buf_len];   // åªæœ‰ä¸€ä»½
static float rf4amp[buf_len];
// ...

static float X1_avg = 0;  // å…¨å±€å”¯ä¸€çš„å¹³å‡å€¼
static float Y1_avg = 0;

// å…¨å±€è®¿é—®ç‚¹
float GetRFInfo(int channel, int type)
{
    // è¿”å›å•ä¾‹æ•°æ®
    return rf3amp[0];
}
```

### ä¼˜ç‚¹

âœ… **å”¯ä¸€æ•°æ®æº**ï¼šæ‰€æœ‰çº¿ç¨‹è®¿é—®åŒä¸€ä»½æ•°æ®
âœ… **èŠ‚çœå†…å­˜**ï¼šä¸é‡å¤å­˜å‚¨æ•°æ®
âœ… **å…¨å±€è®¿é—®**ï¼šä»»ä½•åœ°æ–¹éƒ½å¯ä»¥è®¿é—®

### æ³¨æ„äº‹é¡¹

âš ï¸ **çº¿ç¨‹å®‰å…¨**ï¼šéœ€è¦åŠ é”ä¿æŠ¤
âš ï¸ **å…¨å±€çŠ¶æ€**ï¼šå¯èƒ½å¯¼è‡´è€¦åˆ

## 5ï¸âƒ£ è§‚å¯Ÿè€…æ¨¡å¼ï¼ˆObserver Patternï¼‰

### æ¨¡å¼å®šä¹‰

å®šä¹‰å¯¹è±¡é—´çš„ä¸€å¯¹å¤šä¾èµ–ï¼Œå½“ä¸€ä¸ªå¯¹è±¡çŠ¶æ€æ”¹å˜æ—¶ï¼Œæ‰€æœ‰ä¾èµ–è€…éƒ½å¾—åˆ°é€šçŸ¥ã€‚

### BPMIOCåº”ç”¨ï¼šI/Oä¸­æ–­æ‰«æ

```
ä¸»é¢˜ï¼ˆSubjectï¼‰: pthreadæ•°æ®é‡‡é›†çº¿ç¨‹
è§‚å¯Ÿè€…ï¼ˆObserverï¼‰: æ‰€æœ‰"I/O Intr"çš„Record

pthreadçº¿ç¨‹                  IOSCANPVT                Recordåˆ—è¡¨
    |                          |                       |
    | funcTriggerAllDataReached()                     |
    |                          |                       |
    | scanIoRequest()          |                       |
    |â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>|                       |
    |  (é€šçŸ¥è§‚å¯Ÿè€…)             |                       |
    |                          | éå†Recordåˆ—è¡¨         |
    |                          |â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>|
    |                          |                       | read_ai()
    |                          |                       | read_wf()
    |                          |<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€|
    |                          |                       |
```

### ä»£ç ç¤ºä¾‹

```c
// Subject: pthreadçº¿ç¨‹
void *pthread(void *arg)
{
    while (1) {
        // çŠ¶æ€æ”¹å˜ï¼šç¡¬ä»¶æ•°æ®å‡†å¤‡å¥½
        funcTriggerAllDataReached();

        // é€šçŸ¥æ‰€æœ‰è§‚å¯Ÿè€…
        scanIoRequest(TriginScanPvt);  // â† é€šçŸ¥

        usleep(100000);
    }
}

// Observer: Record
record(ai, "LLRF:BPM:RF3Amp") {
    field(SCAN, "I/O Intr")  // â† æ³¨å†Œä¸ºè§‚å¯Ÿè€…
    // å½“æ”¶åˆ°é€šçŸ¥æ—¶ï¼Œè°ƒç”¨read_ai()
}
```

### ä¼˜ç‚¹

âœ… **è§£è€¦**ï¼šSubjectä¸éœ€è¦çŸ¥é“æœ‰å“ªäº›Observer
âœ… **åŠ¨æ€è®¢é˜…**ï¼šObserverå¯ä»¥åŠ¨æ€æ³¨å†Œ/æ³¨é”€
âœ… **å¹¿æ’­é€šä¿¡**ï¼šä¸€æ¬¡é€šçŸ¥ï¼Œæ‰€æœ‰Observerå“åº”

## 6ï¸âƒ£ é€‚é…å™¨æ¨¡å¼ï¼ˆAdapter Patternï¼‰

### æ¨¡å¼å®šä¹‰

å°†ä¸€ä¸ªç±»çš„æ¥å£è½¬æ¢æˆå®¢æˆ·æœŸæœ›çš„å¦ä¸€ä¸ªæ¥å£ã€‚

### BPMIOCåº”ç”¨ï¼šç¡¬ä»¶åº“é€‚é…

```
ç›®æ ‡æ¥å£ï¼ˆTargetï¼‰ï¼šReadData(offset, channel, type)
      â†‘
      | é€‚é…
      |
è¢«é€‚é…è€…ï¼ˆAdapteeï¼‰ï¼šfuncGetRfInfo(...), funcGetXYPosition(...), ...
```

### ä»£ç ç¤ºä¾‹

```c
// è¢«é€‚é…è€…ï¼šç¡¬ä»¶åº“æä¾›çš„æ¥å£ï¼ˆä¸ç»Ÿä¸€ï¼‰
int (*funcGetRfInfo)(float *Amp, float *Phase, ...);  // å¤æ‚
int (*funcGetXYPosition)(int channel);                // ç®€å•
int (*funcGetVabcdValue)(int channel);               // ä¸åŒç­¾å

// é€‚é…å™¨ï¼šç»Ÿä¸€çš„æ¥å£
float ReadData(int offset, int channel, int type)
{
    switch (offset)
    {
        case 0:  // é€‚é…GetRfInfo
        {
            float amp[8], phase[8], power[8];
            float vbpm, ibpm, vcri, icri;
            int pset;

            // è°ƒç”¨åŸå§‹æ¥å£
            funcGetRfInfo(amp, phase, power, &vbpm, &ibpm, &vcri, &icri, &pset);

            // è½¬æ¢ä¸ºç»Ÿä¸€æ ¼å¼
            if (type == AMP)
                return amp[channel];
            else
                return phase[channel];
        }

        case 7:  // é€‚é…GetXYPosition
            // ç›´æ¥è°ƒç”¨
            return funcGetXYPosition(channel);

        // ...
    }
}
```

### ä¼˜ç‚¹

âœ… **æ¥å£ç»Ÿä¸€**ï¼šå¯¹å¤–æä¾›ä¸€è‡´çš„æ¥å£
âœ… **éš”ç¦»å˜åŒ–**ï¼šç¡¬ä»¶åº“æ¥å£å˜åŒ–ä¸å½±å“ä¸Šå±‚
âœ… **å¤ç”¨ç°æœ‰ä»£ç **ï¼šä¸éœ€è¦ä¿®æ”¹ç¡¬ä»¶åº“

## 7ï¸âƒ£ å¤–è§‚æ¨¡å¼ï¼ˆFacade Patternï¼‰

### æ¨¡å¼å®šä¹‰

ä¸ºå­ç³»ç»Ÿä¸­çš„ä¸€ç»„æ¥å£æä¾›ä¸€ä¸ªç»Ÿä¸€çš„é«˜å±‚æ¥å£ã€‚

### BPMIOCåº”ç”¨ï¼šdriverWrapper

```
å¤æ‚å­ç³»ç»Ÿï¼š
â”œâ”€ funcGetRfInfo()
â”œâ”€ funcGetXYPosition()
â”œâ”€ funcGetVabcdValue()
â”œâ”€ funcGetBPMPhaseValue()
â”œâ”€ funcGetxyProtect()
â”œâ”€ funcTriggerAllDataReached()
â””â”€ ... 50+ä¸ªå‡½æ•°

     â†“ å¤–è§‚

ç®€åŒ–æ¥å£ï¼š
â”œâ”€ ReadData()        â† è¯»å–æ‰€æœ‰ç±»å‹æ•°æ®
â”œâ”€ SetReg()          â† å†™å…¥æ‰€æœ‰ç±»å‹æ•°æ®
â”œâ”€ readWaveform()    â† è¯»å–æ‰€æœ‰æ³¢å½¢
â””â”€ InitDevice()      â† åˆå§‹åŒ–æ‰€æœ‰ç¡¬ä»¶
```

### ä»£ç ç¤ºä¾‹

```c
// å¤–è§‚æ¥å£ï¼šç®€åŒ–çš„API
float ReadData(int offset, int channel, int type);
void SetReg(int offset, int channel, float val);
void readWaveform(int offset, int ch_N, unsigned int nelem, float *data, ...);

// å®¢æˆ·ç«¯ï¼ˆè®¾å¤‡æ”¯æŒå±‚ï¼‰ä½¿ç”¨å¤–è§‚
long read_ai(aiRecord *prec)
{
    // åªéœ€è¦è°ƒç”¨ä¸€ä¸ªç®€å•çš„æ¥å£
    float value = ReadData(offset, channel, type);

    // è€Œä¸æ˜¯ï¼š
    // if (offset == 0) {
    //     float amp[8], phase[8], ...;
    //     funcGetRfInfo(amp, phase, ...);
    //     value = amp[channel];
    // } else if (offset == 7) {
    //     value = funcGetXYPosition(channel);
    // } ...
}
```

### ä¼˜ç‚¹

âœ… **ç®€åŒ–æ¥å£**ï¼šå¯¹å¤–æä¾›ç®€å•æ˜“ç”¨çš„API
âœ… **é™ä½è€¦åˆ**ï¼šå®¢æˆ·ç«¯ä¸ç›´æ¥ä¾èµ–å­ç³»ç»Ÿ
âœ… **åˆ†å±‚æ¸…æ™°**ï¼šæ˜ç¡®å®šä¹‰å„å±‚èŒè´£

## ğŸ¯ è®¾è®¡æ¨¡å¼ç»„åˆåº”ç”¨

### å®Œæ•´æ•°æ®è¯»å–æµç¨‹

```
1. å·¥å‚æ¨¡å¼ï¼šåˆ›å»ºè®¾å¤‡æ”¯æŒå¯¹è±¡
   devAi.init_record_ai(prec)
   â””â”€> åˆ›å»ºDevPvt

2. è§‚å¯Ÿè€…æ¨¡å¼ï¼šæ³¨å†ŒI/Oä¸­æ–­
   pthread: scanIoRequest(TriginScanPvt)
   â””â”€> é€šçŸ¥æ‰€æœ‰è§‚å¯Ÿè€…

3. å¤–è§‚æ¨¡å¼ï¼šç®€åŒ–æ¥å£è°ƒç”¨
   read_ai() è°ƒç”¨ ReadData()
   â””â”€> éšè—å¤æ‚çš„ç¡¬ä»¶æ¥å£

4. ç­–ç•¥æ¨¡å¼ï¼šé€‰æ‹©è¯»å–ç­–ç•¥
   ReadData(offset, ...)
   â””â”€> switch(offset) é€‰æ‹©ç­–ç•¥

5. é€‚é…å™¨æ¨¡å¼ï¼šé€‚é…ç¡¬ä»¶æ¥å£
   case 0: funcGetRfInfo(...) â†’ return amp[channel]
   â””â”€> è½¬æ¢ä¸ºç»Ÿä¸€æ ¼å¼

6. å•ä¾‹æ¨¡å¼ï¼šè®¿é—®å…¨å±€æ•°æ®
   return rf3amp[0]
   â””â”€> å”¯ä¸€æ•°æ®æº
```

## ğŸ“Š è®¾è®¡æ¨¡å¼å¯¹æ¯”

| æ¨¡å¼ | ä¸»è¦ç›®çš„ | é€‚ç”¨åœºæ™¯ | BPMIOCå®ä¾‹ |
|------|---------|---------|-----------|
| **åˆ†å±‚æ¶æ„** | åˆ†ç¦»å…³æ³¨ç‚¹ | å¤æ‚ç³»ç»Ÿ | ä¸‰å±‚æ¶æ„ |
| **ç­–ç•¥æ¨¡å¼** | ç®—æ³•å¯æ›¿æ¢ | å¤šç§ç­–ç•¥ | Offsetç³»ç»Ÿ |
| **å·¥å‚æ¨¡å¼** | å¯¹è±¡åˆ›å»º | å¤šç§ç±»å‹ | dset |
| **å•ä¾‹æ¨¡å¼** | å”¯ä¸€å®ä¾‹ | å…¨å±€çŠ¶æ€ | å…¨å±€ç¼“å†²åŒº |
| **è§‚å¯Ÿè€…æ¨¡å¼** | äº‹ä»¶é€šçŸ¥ | ä¸€å¯¹å¤šä¾èµ– | I/Oä¸­æ–­æ‰«æ |
| **é€‚é…å™¨æ¨¡å¼** | æ¥å£è½¬æ¢ | æ¥å£ä¸å…¼å®¹ | ç¡¬ä»¶åº“å°è£… |
| **å¤–è§‚æ¨¡å¼** | ç®€åŒ–æ¥å£ | å¤æ‚å­ç³»ç»Ÿ | driverWrapper |

## âœ… å­¦ä¹ æ£€æŸ¥ç‚¹

å®Œæˆæœ¬æ–‡åï¼Œä½ åº”è¯¥èƒ½å¤Ÿå›ç­”ï¼š

1. **æ¨¡å¼è¯†åˆ«**ï¼š
   - [ ] BPMIOCä½¿ç”¨äº†å“ªäº›è®¾è®¡æ¨¡å¼ï¼Ÿ
   - [ ] æ¯ä¸ªæ¨¡å¼è§£å†³ä»€ä¹ˆé—®é¢˜ï¼Ÿ
   - [ ] Offsetç³»ç»Ÿæ˜¯å“ªç§æ¨¡å¼ï¼Ÿ

2. **æ¨¡å¼åº”ç”¨**ï¼š
   - [ ] å¦‚ä½•ç”¨ç­–ç•¥æ¨¡å¼æ·»åŠ æ–°offsetï¼Ÿ
   - [ ] I/Oä¸­æ–­æ‰«æç”¨äº†ä»€ä¹ˆæ¨¡å¼ï¼Ÿ
   - [ ] dsetæ˜¯å“ªç§æ¨¡å¼çš„åº”ç”¨ï¼Ÿ

3. **æ¶æ„è®¾è®¡**ï¼š
   - [ ] ä¸ºä»€ä¹ˆä½¿ç”¨åˆ†å±‚æ¶æ„ï¼Ÿ
   - [ ] å¤–è§‚æ¨¡å¼çš„ä¼˜ç‚¹ï¼Ÿ
   - [ ] å•ä¾‹æ¨¡å¼çš„çº¿ç¨‹å®‰å…¨é—®é¢˜ï¼Ÿ

## ğŸ”— ç›¸å…³æ–‡æ¡£

- **[01-architecture-overview.md](./01-architecture-overview.md)** - æ¶æ„æ€»è§ˆ
- **[05-offset-system.md](./05-offset-system.md)** - Offsetç³»ç»Ÿè¯¦è§£

## ğŸ“š æ‰©å±•é˜…è¯»

### è®¾è®¡æ¨¡å¼ç»å…¸ä¹¦ç±
- ã€ŠDesign Patterns: Elements of Reusable Object-Oriented Softwareã€‹(Gang of Four)
- ã€ŠHead First Design Patternsã€‹

### æ¶æ„è®¾è®¡
- ã€ŠClean Architectureã€‹(Robert C. Martin)
- ã€ŠSoftware Architecture Patternsã€‹(Mark Richards)

---

**å®Œæˆ**: Part 3å…¨éƒ¨9ä¸ªæ–‡æ¡£å·²å®Œæˆï¼ğŸ‰

**ä¸‹ä¸€æ­¥**: [Part 4: é©±åŠ¨å±‚è¯¦è§£](/docs/part4-driver-layer/)

**å®è·µç»ƒä¹ **:
1. è¯†åˆ«ä½ è‡ªå·±é¡¹ç›®ä¸­ä½¿ç”¨çš„è®¾è®¡æ¨¡å¼
2. å°è¯•ç”¨ç­–ç•¥æ¨¡å¼é‡æ„ä¸€æ®µif-elseä»£ç 
3. ç»˜åˆ¶BPMIOCçš„UMLç±»å›¾ï¼Œæ ‡æ³¨ä½¿ç”¨çš„è®¾è®¡æ¨¡å¼
4. æ€è€ƒï¼šå¦‚æœé‡æ–°è®¾è®¡BPMIOCï¼Œä¼šä½¿ç”¨å“ªäº›å…¶ä»–æ¨¡å¼ï¼Ÿ
